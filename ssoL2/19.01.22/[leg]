
pulseaudio: pa_context_connect() failed
pulseaudio: Reason: Connection refused
pulseaudio: Failed to initialize PA contextaudio: Could not init `pa' audio driver
ALSA lib confmisc.c:768:(parse_card) cannot find card '0'
ALSA lib conf.c:4292:(_snd_config_evaluate) function snd_func_card_driver returned error: No such file or directory
ALSA lib confmisc.c:392:(snd_func_concat) error evaluating strings
ALSA lib conf.c:4292:(_snd_config_evaluate) function snd_func_concat returned error: No such file or directory
ALSA lib confmisc.c:1251:(snd_func_refer) error evaluating name
ALSA lib conf.c:4292:(_snd_config_evaluate) function snd_func_refer returned error: No such file or directory
ALSA lib conf.c:4771:(snd_config_expand) Evaluate error: No such file or directory
ALSA lib pcm.c:2266:(snd_pcm_open_noupdate) Unknown PCM default
alsa: Could not initialize DAC
alsa: Failed to open `default':
alsa: Reason: No such file or directory
ALSA lib confmisc.c:768:(parse_card) cannot find card '0'
ALSA lib conf.c:4292:(_snd_config_evaluate) function snd_func_card_driver returned error: No such file or directory
ALSA lib confmisc.c:392:(snd_func_concat) error evaluating strings
ALSA lib conf.c:4292:(_snd_config_evaluate) function snd_func_concat returned error: No such file or directory
ALSA lib confmisc.c:1251:(snd_func_refer) error evaluating name
ALSA lib conf.c:4292:(_snd_config_evaluate) function snd_func_refer returned error: No such file or directory
ALSA lib conf.c:4771:(snd_config_expand) Evaluate error: No such file or directory
ALSA lib pcm.c:2266:(snd_pcm_open_noupdate) Unknown PCM default
alsa: Could not initialize DAC
alsa: Failed to open `default':
alsa: Reason: No such file or directory
audio: Failed to create voice `lm4549.out'
Uncompressing Linux... done, booting the kernel.
[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Linux version 3.11.4 (acez@pondicherry) (gcc version 4.7.3 (Sourcery CodeBench Lite 2013.05-24) ) #5 Sat Oct 12 00:15:00 EDT 2013
[    0.000000] CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr=00093177
[    0.000000] CPU: VIVT data cache, VIVT instruction cache
[    0.000000] Machine: ARM-Versatile PB
[    0.000000] Memory policy: ECC disabled, Data cache writeback
[    0.000000] sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 178956ms
[    0.000000] Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 16256
[    0.000000] Kernel command line: 'root=/dev/ram rw console=ttyAMA0 rdinit=/sbin/init oops=panic panic=1 quiet'
[    0.000000] PID hash table entries: 256 (order: -2, 1024 bytes)
[    0.000000] Dentry cache hash table entries: 8192 (order: 3, 32768 bytes)
[    0.000000] Inode-cache hash table entries: 4096 (order: 2, 16384 bytes)
[    0.000000] Memory: 59760K/65536K available (2522K kernel code, 150K rwdata, 656K rodata, 112K init, 93K bss, 5776K reserved)
[    0.000000] Virtual kernel memory layout:
[    0.000000]     vector  : 0xffff0000 - 0xffff1000   (   4 kB)
[    0.000000]     fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
[    0.000000]     vmalloc : 0xc4800000 - 0xff000000   ( 936 MB)
[    0.000000]     lowmem  : 0xc0000000 - 0xc4000000   (  64 MB)
[    0.000000]     modules : 0xbf000000 - 0xc0000000   (  16 MB)
[    0.000000]       .text : 0xc0008000 - 0xc0322cc8   (3180 kB)
[    0.000000]       .init : 0xc0323000 - 0xc033f22c   ( 113 kB)
[    0.000000]       .data : 0xc0340000 - 0xc0365b20   ( 151 kB)
[    0.000000]        .bss : 0xc0365b20 - 0xc037d2bc   (  94 kB)
[    0.000000] NR_IRQS:224
[    0.000000] VIC @f1140000: id 0x00041190, vendor 0x41
[    0.000000] FPGA IRQ chip 0 "SIC" @ f1003000, 13 irqs
[    0.000000] Console: colour dummy device 80x30
[    0.035056] Calibrating delay loop... 230.80 BogoMIPS (lpj=1154048)
[    0.173914] pid_max: default: 32768 minimum: 301
[    0.175659] Mount-cache hash table entries: 512
[    0.201728] CPU: Testing write buffer coherency: ok
[    0.220314] Setting up static identity map for 0xc0265c80 - 0xc0265cbc
[    0.261434] NET: Registered protocol family 16
[    0.269619] DMA: preallocated 256 KiB pool for atomic coherent allocations
[    0.291154] Serial: AMBA PL011 UART driver
[    0.296235] dev:f1: ttyAMA0 at MMIO 0x101f1000 (irq = 44) is a PL011 rev1
[    0.346440] console [ttyAMA0] enabled
[    0.352123] dev:f2: ttyAMA1 at MMIO 0x101f2000 (irq = 45) is a PL011 rev1
[    0.357335] dev:f3: ttyAMA2 at MMIO 0x101f3000 (irq = 46) is a PL011 rev1
[    0.361319] fpga:09: ttyAMA3 at MMIO 0x10009000 (irq = 70) is a PL011 rev1
[    0.411310] bio: create slab <bio-0> at 0
[    0.457316] Switched to clocksource timer3
[    0.507540] NET: Registered protocol family 2
[    0.534797] TCP established hash table entries: 512 (order: 0, 4096 bytes)
[    0.536346] TCP bind hash table entries: 512 (order: -1, 2048 bytes)
[    0.537176] TCP: Hash tables configured (established 512 bind 512)
[    0.538794] TCP: reno registered
[    0.541787] UDP hash table entries: 256 (order: 0, 4096 bytes)
[    0.545394] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
[    0.548730] NET: Registered protocol family 1
[    0.570746] RPC: Registered named UNIX socket transport module.
[    0.574751] RPC: Registered udp transport module.
[    0.575260] RPC: Registered tcp transport module.
[    0.575889] RPC: Registered tcp NFSv4.1 backchannel transport module.
[    0.597009] Trying to unpack rootfs image as initramfs...
[    1.156135] Freeing initrd memory: 1584K (c2000000 - c218c000)
[    1.158010] NetWinder Floating Point Emulator V0.97 (double precision)
[    1.172014] Installing knfsd (copyright (C) 1996 okir@monad.swb.de).
[    1.174729] msgmni has been set to 119
[    1.224443] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 254)
[    1.225730] io scheduler noop registered
[    1.226209] io scheduler deadline registered
[    1.226940] io scheduler cfq registered (default)
[    1.228292] clcd-pl11x dev:20: PL110 rev0 at 0x10120000
[    1.235888] clcd-pl11x dev:20: Versatile hardware, VGA display
[    1.277385] Console: switching to colour frame buffer device 80x60
[    1.325834] brd: module loaded
[    1.335011] physmap platform flash device: 04000000 at 34000000
[    1.371877] physmap-flash.0: Found 1 x32 devices at 0x0 in 32-bit bank. Manufacturer ID 0x000000 Chip ID 0x000000
[    1.393627] Intel/Sharp Extended Query Table at 0x0031
[    1.400832] Using buffer write method
[    1.425078] smc91x.c: v1.1, sep 22 2004 by Nicolas Pitre <nico@fluxnic.net>
[    1.456975] eth0: SMC91C11xFD (rev 1) at c496e000 IRQ 57 [nowait]
[    1.457865] eth0: Ethernet addr: 52:54:00:12:34:56
[    1.460313] mousedev: PS/2 mouse device common for all mice
[    1.475035] TCP: cubic registered
[    1.475813] NET: Registered protocol family 17
[    1.476926] NET: Registered protocol family 37
[    1.477839] VFP support v0.3: implementor 41 architecture 1 part 10 variant 9 rev 0
[    1.495027] Freeing unused kernel memory: 112K (c0323000 - c033f000)
[    1.567192] input: AT Raw Set 2 keyboard as /devices/fpga:06/serio0/input/input0
cttyhack: can't open '/dev/ttyS0': No such file or directory
sh: can't access tty; job control turned off
/ $ [    2.172237] input: ImExPS/2 Generic Explorer Mouse as /devices/fpga:07/serio1/input/input1


---------------------------------------------------------------------------------------
띠용?









아 일단 문제는



Daddy told me I should study arm.
But I prefer to study my leg!

Download : http://pwnable.kr/bin/leg.c
Download : http://pwnable.kr/bin/leg.asm

ssh leg@pwnable.kr -p2222 (pw:guest)


--------------------------------------------------------
ssh로 들가보니까
저렇게 이상한게 나옴...흠 ;;
그래서 다운로드해서 c파일과 어셈블리를 보기로 결정 !










#include <stdio.h>
#include <fcntl.h>
int key1(){
	asm("mov r3, pc\n");
}
int key2(){
	asm(
	"push	{r6}\n"
	"add	r6, pc, $1\n"
	"bx	r6\n"
	".code   16\n"
	"mov	r3, pc\n"
	"add	r3, $0x4\n"
	"push	{r3}\n"
	"pop	{pc}\n"
	".code	32\n"
	"pop	{r6}\n"
	);
}
int key3(){
	asm("mov r3, lr\n");
}
int main(){
	int key=0;
	printf("Daddy has very strong arm! : ");
	scanf("%d", &key);
	if( (key1()+key2()+key3()) == key ){
		printf("Congratz!\n");
		int fd = open("flag", O_RDONLY);
		char buf[100];
		int r = read(fd, buf, 100);
		write(0, buf, r);
	}
	else{
		printf("I have strong leg :P\n");
	}
	return 0;
}


---------------------------------------------------------------
위는 leg.c !


main함수부터 보면은 key int형 입력 받구 ~

핵심은
" key1()+key2()+key3() == key " 이거 같앙 !!
key함수들과 입력한 key값이 같으면 끝나는 듯 싶옹 ~~~~

그래서 위에 key 함수들 봤는데
뭐래는 겨.........

그래서 c코드 말고 다운로드 하나 더 한 어셈블리를 보았지 !
어셈블리에서 각 key함수들의 return 값을 알면 되지 않을까 싶어서 !!!!!!!! 이게 주 목적이야 어셈블리 본것의 ~













(gdb) disass main
Dump of assembler code for function main:
   0x00008d3c <+0>:	push	{r4, r11, lr}
   0x00008d40 <+4>:	add	r11, sp, #8
   0x00008d44 <+8>:	sub	sp, sp, #12
   0x00008d48 <+12>:	mov	r3, #0
   0x00008d4c <+16>:	str	r3, [r11, #-16]
   0x00008d50 <+20>:	ldr	r0, [pc, #104]	; 0x8dc0 <main+132>
   0x00008d54 <+24>:	bl	0xfb6c <printf>
   0x00008d58 <+28>:	sub	r3, r11, #16
   0x00008d5c <+32>:	ldr	r0, [pc, #96]	; 0x8dc4 <main+136>
   0x00008d60 <+36>:	mov	r1, r3
   0x00008d64 <+40>:	bl	0xfbd8 <__isoc99_scanf>
   0x00008d68 <+44>:	bl	0x8cd4 <key1>
   0x00008d6c <+48>:	mov	r4, r0
   0x00008d70 <+52>:	bl	0x8cf0 <key2>
   0x00008d74 <+56>:	mov	r3, r0
   0x00008d78 <+60>:	add	r4, r4, r3
   0x00008d7c <+64>:	bl	0x8d20 <key3>
   0x00008d80 <+68>:	mov	r3, r0
   0x00008d84 <+72>:	add	r2, r4, r3
   0x00008d88 <+76>:	ldr	r3, [r11, #-16]
   0x00008d8c <+80>:	cmp	r2, r3
   0x00008d90 <+84>:	bne	0x8da8 <main+108>
   0x00008d94 <+88>:	ldr	r0, [pc, #44]	; 0x8dc8 <main+140>
   0x00008d98 <+92>:	bl	0x1050c <puts>
   0x00008d9c <+96>:	ldr	r0, [pc, #40]	; 0x8dcc <main+144>
   0x00008da0 <+100>:	bl	0xf89c <system>
   0x00008da4 <+104>:	b	0x8db0 <main+116>
   0x00008da8 <+108>:	ldr	r0, [pc, #32]	; 0x8dd0 <main+148>
   0x00008dac <+112>:	bl	0x1050c <puts>
   0x00008db0 <+116>:	mov	r3, #0
   0x00008db4 <+120>:	mov	r0, r3
   0x00008db8 <+124>:	sub	sp, r11, #8
   0x00008dbc <+128>:	pop	{r4, r11, pc}
   0x00008dc0 <+132>:	andeq	r10, r6, r12, lsl #9
   0x00008dc4 <+136>:	andeq	r10, r6, r12, lsr #9
   0x00008dc8 <+140>:			; <UNDEFINED> instruction: 0x0006a4b0
   0x00008dcc <+144>:			; <UNDEFINED> instruction: 0x0006a4bc
   0x00008dd0 <+148>:	andeq	r10, r6, r4, asr #9
End of assembler dump.
(gdb) disass key1
Dump of assembler code for function key1:
   0x00008cd4 <+0>:	push	{r11}		; (str r11, [sp, #-4]!)
   0x00008cd8 <+4>:	add	r11, sp, #0
   0x00008cdc <+8>:	mov	r3, pc
   0x00008ce0 <+12>:	mov	r0, r3
   0x00008ce4 <+16>:	sub	sp, r11, #0
   0x00008ce8 <+20>:	pop	{r11}		; (ldr r11, [sp], #4)
   0x00008cec <+24>:	bx	lr
End of assembler dump.
(gdb) disass key2
Dump of assembler code for function key2:
   0x00008cf0 <+0>:	push	{r11}		; (str r11, [sp, #-4]!)
   0x00008cf4 <+4>:	add	r11, sp, #0
   0x00008cf8 <+8>:	push	{r6}		; (str r6, [sp, #-4]!)
   0x00008cfc <+12>:	add	r6, pc, #1
   0x00008d00 <+16>:	bx	r6
   0x00008d04 <+20>:	mov	r3, pc
   0x00008d06 <+22>:	adds	r3, #4
   0x00008d08 <+24>:	push	{r3}
   0x00008d0a <+26>:	pop	{pc}
   0x00008d0c <+28>:	pop	{r6}		; (ldr r6, [sp], #4)
   0x00008d10 <+32>:	mov	r0, r3
   0x00008d14 <+36>:	sub	sp, r11, #0
   0x00008d18 <+40>:	pop	{r11}		; (ldr r11, [sp], #4)
   0x00008d1c <+44>:	bx	lr
End of assembler dump.
(gdb) disass key3
Dump of assembler code for function key3:
   0x00008d20 <+0>:	push	{r11}		; (str r11, [sp, #-4]!)
   0x00008d24 <+4>:	add	r11, sp, #0
   0x00008d28 <+8>:	mov	r3, lr
   0x00008d2c <+12>:	mov	r0, r3
   0x00008d30 <+16>:	sub	sp, r11, #0
   0x00008d34 <+20>:	pop	{r11}		; (ldr r11, [sp], #4)
   0x00008d38 <+24>:	bx	lr
End of assembler dump.
(gdb) 



-----------------------------------------------------------------------

위는 asm !


우린 key 함수가 궁금하니깐 ~
근데 중간에
   0x00008d68 <+44>:	bl	0x8cd4 <key1>
   0x00008d6c <+48>:	mov	r4, r0
   0x00008d70 <+52>:	bl	0x8cf0 <key2>
   0x00008d74 <+56>:	mov	r3, r0
   0x00008d78 <+60>:	add	r4, r4, r3
   0x00008d7c <+64>:	bl	0x8d20 <key3>
   0x00008d80 <+68>:	mov	r3, r0
   0x00008d84 <+72>:	add	r2, r4, r3
   
함수가 실행되고 r0를 담아서 모아둔다.
고로 각 함수의 어셈블리에서 r0를 추적하면 될거같아 ~~~~
   


key1부터 뜯어보자앙 ~!


(gdb) disass key1
Dump of assembler code for function key1:
   0x00008cd4 <+0>:	push	{r11}		; (str r11, [sp, #-4]!)
   0x00008cd8 <+4>:	add	r11, sp, #0
   0x00008cdc <+8>:	mov	r3, pc
   0x00008ce0 <+12>:	mov	r0, r3
   0x00008ce4 <+16>:	sub	sp, r11, #0
   0x00008ce8 <+20>:	pop	{r11}		; (ldr r11, [sp], #4)
   0x00008cec <+24>:	bx	lr
End of assembler dump.


r3 = pc
r0 = r3 

r0 = pc 가 전부인데, pc가 뭘깡?
